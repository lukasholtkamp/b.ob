<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>B.OB Project: sl::ILidarDriver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">B.OB Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sl</b></li><li class="navelem"><a class="el" href="classsl_1_1ILidarDriver.html">ILidarDriver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsl_1_1ILidarDriver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sl::ILidarDriver Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for sl::ILidarDriver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsl_1_1ILidarDriver.png" usemap="#sl::ILidarDriver_map" alt=""/>
  <map id="sl::ILidarDriver_map" name="sl::ILidarDriver_map">
<area href="classsl_1_1SL__LidarDriver.html" alt="sl::SL_LidarDriver" shape="rect" coords="0,56,136,80"/>
<area href="classsl_1_1SlamtecLidarDriver.html" alt="sl::SlamtecLidarDriver" shape="rect" coords="146,56,282,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a249691a29d26ba959ee58fca8b169c79"><td class="memItemLeft" align="right" valign="top"><a id="a249691a29d26ba959ee58fca8b169c79"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>DEFAULT_TIMEOUT</b> = 2000
 }</td></tr>
<tr class="separator:a249691a29d26ba959ee58fca8b169c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a014e064d0a093d97de8c0a0d16cbfcc3"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a014e064d0a093d97de8c0a0d16cbfcc3">connect</a> (<a class="el" href="classsl_1_1IChannel.html">IChannel</a> *channel)=0</td></tr>
<tr class="separator:a014e064d0a093d97de8c0a0d16cbfcc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f04f486788b2e05d3cb0594bedc62b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a2f04f486788b2e05d3cb0594bedc62b2">disconnect</a> ()=0</td></tr>
<tr class="separator:a2f04f486788b2e05d3cb0594bedc62b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3866969a8f20dc4864121dbb3a0e18f4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a3866969a8f20dc4864121dbb3a0e18f4">isConnected</a> ()=0</td></tr>
<tr class="separator:a3866969a8f20dc4864121dbb3a0e18f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe7498ef58a56502a09f90db9b2a02d"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#adfe7498ef58a56502a09f90db9b2a02d">reset</a> (sl_u32 timeoutInMs=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:adfe7498ef58a56502a09f90db9b2a02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51db6e5508535088dc16540765d459d3"><td class="memItemLeft" align="right" valign="top"><a id="a51db6e5508535088dc16540765d459d3"></a>
virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a51db6e5508535088dc16540765d459d3">getAllSupportedScanModes</a> (std::vector&lt; <a class="el" href="structsl_1_1LidarScanMode.html">LidarScanMode</a> &gt; &amp;outModes, sl_u32 timeoutInMs=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="memdesc:a51db6e5508535088dc16540765d459d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all scan modes that supported by lidar. <br /></td></tr>
<tr class="separator:a51db6e5508535088dc16540765d459d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153e8c1c78746472ab38db67f7e127ba"><td class="memItemLeft" align="right" valign="top"><a id="a153e8c1c78746472ab38db67f7e127ba"></a>
virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a153e8c1c78746472ab38db67f7e127ba">getTypicalScanMode</a> (sl_u16 &amp;outMode, sl_u32 timeoutInMs=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="memdesc:a153e8c1c78746472ab38db67f7e127ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get typical scan mode of lidar. <br /></td></tr>
<tr class="separator:a153e8c1c78746472ab38db67f7e127ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa311abe3245c1c8fc020acd73bb015"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#acaa311abe3245c1c8fc020acd73bb015">startScan</a> (bool force, bool useTypicalScan, sl_u32 options=0, <a class="el" href="structsl_1_1LidarScanMode.html">LidarScanMode</a> *outUsedScanMode=nullptr)=0</td></tr>
<tr class="separator:acaa311abe3245c1c8fc020acd73bb015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bad2a2ca8b338cebf3021acdd9bc77e"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a1bad2a2ca8b338cebf3021acdd9bc77e">startScanExpress</a> (bool force, sl_u16 scanMode, sl_u32 options=0, <a class="el" href="structsl_1_1LidarScanMode.html">LidarScanMode</a> *outUsedScanMode=nullptr, sl_u32 timeout=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:a1bad2a2ca8b338cebf3021acdd9bc77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c28fc76547ec6466c280e9d3939f02d"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a2c28fc76547ec6466c280e9d3939f02d">getHealth</a> (sl_lidar_response_device_health_t &amp;health, sl_u32 timeout=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:a2c28fc76547ec6466c280e9d3939f02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e22091f9ccb6de99c573fd0c8c6711"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a85e22091f9ccb6de99c573fd0c8c6711">getDeviceInfo</a> (sl_lidar_response_device_info_t &amp;info, sl_u32 timeout=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:a85e22091f9ccb6de99c573fd0c8c6711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceecc58638a9017c0e25aa6aa996c3a5"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#aceecc58638a9017c0e25aa6aa996c3a5">checkMotorCtrlSupport</a> (MotorCtrlSupport &amp;motorCtrlSupport, sl_u32 timeout=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:aceecc58638a9017c0e25aa6aa996c3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6770da1d411583f108488a89f7f8213"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#ad6770da1d411583f108488a89f7f8213">getFrequency</a> (const <a class="el" href="structsl_1_1LidarScanMode.html">LidarScanMode</a> &amp;scanMode, const <a class="el" href="structsl__lidar__response__measurement__node__hq__t.html">sl_lidar_response_measurement_node_hq_t</a> *nodes, size_t count, float &amp;frequency)=0</td></tr>
<tr class="separator:ad6770da1d411583f108488a89f7f8213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e0904a036153e2074c76e3b884d64a"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a13e0904a036153e2074c76e3b884d64a">setLidarIpConf</a> (const sl_lidar_ip_conf_t &amp;conf, sl_u32 timeout=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:a13e0904a036153e2074c76e3b884d64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a9f1c7d33c7e00ba4c50b826979353"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a33a9f1c7d33c7e00ba4c50b826979353">getLidarIpConf</a> (sl_lidar_ip_conf_t &amp;conf, sl_u32 timeout=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:a33a9f1c7d33c7e00ba4c50b826979353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07883f0be7acb376ded54e3e559c8f67"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a07883f0be7acb376ded54e3e559c8f67">getDeviceMacAddr</a> (sl_u8 *macAddrArray, sl_u32 timeoutInMs=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:a07883f0be7acb376ded54e3e559c8f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b330a3fa5b5c6a40aaeb04cda53078"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#ad5b330a3fa5b5c6a40aaeb04cda53078">stop</a> (sl_u32 timeout=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:ad5b330a3fa5b5c6a40aaeb04cda53078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5eb71aa411f326980f3f9d5cb5fc56"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#adb5eb71aa411f326980f3f9d5cb5fc56">grabScanDataHq</a> (<a class="el" href="structsl__lidar__response__measurement__node__hq__t.html">sl_lidar_response_measurement_node_hq_t</a> *nodebuffer, size_t &amp;count, sl_u32 timeout=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:adb5eb71aa411f326980f3f9d5cb5fc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034fa50c987a807d04fc5f67fbedaa14"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a034fa50c987a807d04fc5f67fbedaa14">grabScanDataHqWithTimeStamp</a> (<a class="el" href="structsl__lidar__response__measurement__node__hq__t.html">sl_lidar_response_measurement_node_hq_t</a> *nodebuffer, size_t &amp;count, sl_u64 &amp;timestamp_uS, sl_u32 timeout=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:a034fa50c987a807d04fc5f67fbedaa14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2de682cfb265fba3f40a1b4f88647c"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a2e2de682cfb265fba3f40a1b4f88647c">ascendScanData</a> (<a class="el" href="structsl__lidar__response__measurement__node__hq__t.html">sl_lidar_response_measurement_node_hq_t</a> *nodebuffer, size_t count)=0</td></tr>
<tr class="separator:a2e2de682cfb265fba3f40a1b4f88647c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4565ae6236490d19ce3969d0f5ef8cd"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#aa4565ae6236490d19ce3969d0f5ef8cd">getScanDataWithIntervalHq</a> (<a class="el" href="structsl__lidar__response__measurement__node__hq__t.html">sl_lidar_response_measurement_node_hq_t</a> *nodebuffer, size_t &amp;count)=0</td></tr>
<tr class="separator:aa4565ae6236490d19ce3969d0f5ef8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a99f3cecc26fe23b52f59954c9646fb"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a0a99f3cecc26fe23b52f59954c9646fb">setMotorSpeed</a> (sl_u16 speed=DEFAULT_MOTOR_SPEED)=0</td></tr>
<tr class="separator:a0a99f3cecc26fe23b52f59954c9646fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3e7314327d5b686d15c63146002988"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#abd3e7314327d5b686d15c63146002988">getMotorInfo</a> (<a class="el" href="structsl_1_1LidarMotorInfo.html">LidarMotorInfo</a> &amp;motorInfo, sl_u32 timeoutInMs=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:abd3e7314327d5b686d15c63146002988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85da9fd603f808e837f7369450642e47"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a85da9fd603f808e837f7369450642e47">negotiateSerialBaudRate</a> (sl_u32 requiredBaudRate, sl_u32 *baudRateDetected=NULL)=0</td></tr>
<tr class="separator:a85da9fd603f808e837f7369450642e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa4382435b97b4b667131a2be788979"><td class="memItemLeft" align="right" valign="top">virtual LIDARTechnologyType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#adfa4382435b97b4b667131a2be788979">getLIDARTechnologyType</a> (const sl_lidar_response_device_info_t *devInfo=nullptr)=0</td></tr>
<tr class="separator:adfa4382435b97b4b667131a2be788979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f71641fbf5eb8030c4f82680ad722ac"><td class="memItemLeft" align="right" valign="top">virtual LIDARMajorType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a3f71641fbf5eb8030c4f82680ad722ac">getLIDARMajorType</a> (const sl_lidar_response_device_info_t *devInfo=nullptr)=0</td></tr>
<tr class="separator:a3f71641fbf5eb8030c4f82680ad722ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b305cfe45666ad7889ad5e5adc523d8"><td class="memItemLeft" align="right" valign="top">virtual sl_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsl_1_1ILidarDriver.html#a8b305cfe45666ad7889ad5e5adc523d8">getModelNameDescriptionString</a> (std::string &amp;out_description, bool fetchAliasName=true, const sl_lidar_response_device_info_t *devInfo=nullptr, sl_u32 timeout=DEFAULT_TIMEOUT)=0</td></tr>
<tr class="separator:a8b305cfe45666ad7889ad5e5adc523d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2e2de682cfb265fba3f40a1b4f88647c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2de682cfb265fba3f40a1b4f88647c">&#9670;&nbsp;</a></span>ascendScanData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::ascendScanData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__lidar__response__measurement__node__hq__t.html">sl_lidar_response_measurement_node_hq_t</a> *&#160;</td>
          <td class="paramname"><em>nodebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ascending the scan data according to the angle value in the scan.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodebuffer</td><td>Buffer provided by the caller application to do the reorder. Should be retrived from the grabScanData</td></tr>
    <tr><td class="paramname">count</td><td>The caller must initialize this parameter to set the max data count of the provided buffer (in unit of rplidar_response_measurement_node_t). Once the interface returns, this parameter will store the actual received data count. The interface will return SL_RESULT_OPERATION_FAIL when all the scan data is invalid. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#ad1f38ee5aab005944caaf2b9eae3c2b7">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#a26aab253cb981f82abb6b449b9fc4fbd">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="aceecc58638a9017c0e25aa6aa996c3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceecc58638a9017c0e25aa6aa996c3a5">&#9670;&nbsp;</a></span>checkMotorCtrlSupport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::checkMotorCtrlSupport </td>
          <td>(</td>
          <td class="paramtype">MotorCtrlSupport &amp;&#160;</td>
          <td class="paramname"><em>motorCtrlSupport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check whether the device support motor control Note: this API will disable grab.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">motorCtrlSupport</td><td>Return the result. </td></tr>
    <tr><td class="paramname">timeout</td><td>The operation timeout value (in millisecond) for the serial port communication. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#a880bdc480948a782b14827b792aed26a">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#aae8cc21dcfa1ef38d305846f4482e503">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="a014e064d0a093d97de8c0a0d16cbfcc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014e064d0a093d97de8c0a0d16cbfcc3">&#9670;&nbsp;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsl_1_1IChannel.html">IChannel</a> *&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connect to LIDAR via channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The communication channel Note: you should manage the lifecycle of the channel object, make sure it is alive during lidar driver's lifecycle </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#aa79b7ce3c1d934bc5767d6f184937b37">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#a53688c9a36ff1eaa35486b2dc51a5c63">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="a2f04f486788b2e05d3cb0594bedc62b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f04f486788b2e05d3cb0594bedc62b2">&#9670;&nbsp;</a></span>disconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sl::ILidarDriver::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disconnect from the LIDAR </p>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#ac4cce46b8385e3da6539f6ecae6d1eaf">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#a38972fa912bc38910158547f143eca09">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="a85e22091f9ccb6de99c573fd0c8c6711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e22091f9ccb6de99c573fd0c8c6711">&#9670;&nbsp;</a></span>getDeviceInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::getDeviceInfo </td>
          <td>(</td>
          <td class="paramtype">sl_lidar_response_device_info_t &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the device information of the RPLIDAR include the serial number, firmware version, device model etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>The device information returned from the RPLIDAR </td></tr>
    <tr><td class="paramname">timeout</td><td>The operation timeout value (in millisecond) for the serial port communication <br  />
 </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#abec32bc70c4b6affeb6329049613f948">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#a71aea7a5ee881a9ad0300d4f8f09564d">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="a07883f0be7acb376ded54e3e559c8f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07883f0be7acb376ded54e3e559c8f67">&#9670;&nbsp;</a></span>getDeviceMacAddr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::getDeviceMacAddr </td>
          <td>(</td>
          <td class="paramtype">sl_u8 *&#160;</td>
          <td class="paramname"><em>macAddrArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeoutInMs</em> = <code>DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get LPX series lidar's MAC address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">macAddrArray</td><td>The device MAC information returned from the LPX series lidar Notice: the macAddrArray must point to a valid buffer with at least 6 bytes length Otherwise, buffer overwrite will occur </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#acee55560568509e4be31eaaf3a53fb7e">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#a6d0a33645ada05a6aec32c6b75c53344">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="ad6770da1d411583f108488a89f7f8213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6770da1d411583f108488a89f7f8213">&#9670;&nbsp;</a></span>getFrequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::getFrequency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsl_1_1LidarScanMode.html">LidarScanMode</a> &amp;&#160;</td>
          <td class="paramname"><em>scanMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsl__lidar__response__measurement__node__hq__t.html">sl_lidar_response_measurement_node_hq_t</a> *&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate LIDAR's current scanning frequency from the given scan data Please refer to the application note doc for details Remark: the calcuation will be incorrect if the specified scan data doesn't contains enough data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scanMode</td><td>Lidar's current scan mode </td></tr>
    <tr><td class="paramname">nodes</td><td>Current scan's measurements </td></tr>
    <tr><td class="paramname">count</td><td>The number of sample nodes inside the given buffer </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SL__LidarDriver.html#a38a5f20574006eb397f8c1fe67e89516">sl::SL_LidarDriver</a>, and <a class="el" href="classsl_1_1SlamtecLidarDriver.html#ae715a400b05523184b53bbb3c7753617">sl::SlamtecLidarDriver</a>.</p>

</div>
</div>
<a id="a2c28fc76547ec6466c280e9d3939f02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c28fc76547ec6466c280e9d3939f02d">&#9670;&nbsp;</a></span>getHealth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::getHealth </td>
          <td>(</td>
          <td class="paramtype">sl_lidar_response_device_health_t &amp;&#160;</td>
          <td class="paramname"><em>health</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the health status of the RPLIDAR The host system can use this operation to check whether RPLIDAR is in the self-protection mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">health</td><td>The health status info returned from the RPLIDAR</td></tr>
    <tr><td class="paramname">timeout</td><td>The operation timeout value (in millisecond) for the serial port communication <br  />
 </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#ab299798953b5feca07294ac4a25f5160">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#afa4d086aa22e88fd46cfcf4917363315">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="a33a9f1c7d33c7e00ba4c50b826979353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a9f1c7d33c7e00ba4c50b826979353">&#9670;&nbsp;</a></span>getLidarIpConf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::getLidarIpConf </td>
          <td>(</td>
          <td class="paramtype">sl_lidar_ip_conf_t &amp;&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get LPX and S2E series lidar's static IP address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>Network parameter that LPX series lidar owned </td></tr>
    <tr><td class="paramname">timeout</td><td>The operation timeout value (in millisecond) for the ethernet udp communication </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#afb329aaa2f757ad1db54763f845b0c8c">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#a63ad8bc8380a16ac5167071d5cb172cb">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="a3f71641fbf5eb8030c4f82680ad722ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f71641fbf5eb8030c4f82680ad722ac">&#9670;&nbsp;</a></span>getLIDARMajorType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual LIDARMajorType sl::ILidarDriver::getLIDARMajorType </td>
          <td>(</td>
          <td class="paramtype">const sl_lidar_response_device_info_t *&#160;</td>
          <td class="paramname"><em>devInfo</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the Major Type (Series Info) of the LIDAR</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devInfo</td><td>The device info used to deduct the result If NULL is specified, a driver cached version of the connected LIDAR will be used </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#aea88514a62295de00cc1ea8f95c7a178">sl::SlamtecLidarDriver</a>.</p>

</div>
</div>
<a id="adfa4382435b97b4b667131a2be788979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa4382435b97b4b667131a2be788979">&#9670;&nbsp;</a></span>getLIDARTechnologyType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual LIDARTechnologyType sl::ILidarDriver::getLIDARTechnologyType </td>
          <td>(</td>
          <td class="paramtype">const sl_lidar_response_device_info_t *&#160;</td>
          <td class="paramname"><em>devInfo</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the technology of the LIDAR's measurement system</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devInfo</td><td>The device info used to deduct the result If NULL is specified, a driver cached version of the connected LIDAR will be used </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#a9557b5758b2c249a0f86361b8f04f555">sl::SlamtecLidarDriver</a>.</p>

</div>
</div>
<a id="a8b305cfe45666ad7889ad5e5adc523d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b305cfe45666ad7889ad5e5adc523d8">&#9670;&nbsp;</a></span>getModelNameDescriptionString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::getModelNameDescriptionString </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>out_description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fetchAliasName</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sl_lidar_response_device_info_t *&#160;</td>
          <td class="paramname"><em>devInfo</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the Model Name of the LIDAR The result will be somthing like: "A1M8" or "S1M1" or "A3M1-R1"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_description</td><td>The output string that contains the generated model name</td></tr>
    <tr><td class="paramname">fetchAliasName</td><td>If set to true, a communication will be taken to ask if there is any Alias name availabe </td></tr>
    <tr><td class="paramname">devInfo</td><td>The device info used to deduct the result If NULL is specified, a driver cached version of the connected LIDAR will be used </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout value used by potential data communication </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#a2c682757fda95590d285d56e80f811a3">sl::SlamtecLidarDriver</a>.</p>

</div>
</div>
<a id="abd3e7314327d5b686d15c63146002988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3e7314327d5b686d15c63146002988">&#9670;&nbsp;</a></span>getMotorInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::getMotorInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl_1_1LidarMotorInfo.html">LidarMotorInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>motorInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeoutInMs</em> = <code>DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the motor information of the RPLIDAR include the max speed, min speed, desired speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">motorInfo</td><td>The motor information returned from the RPLIDAR </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#a38d8e7545206faeb98d761530b341518">sl::SlamtecLidarDriver</a>.</p>

</div>
</div>
<a id="aa4565ae6236490d19ce3969d0f5ef8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4565ae6236490d19ce3969d0f5ef8cd">&#9670;&nbsp;</a></span>getScanDataWithIntervalHq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::getScanDataWithIntervalHq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__lidar__response__measurement__node__hq__t.html">sl_lidar_response_measurement_node_hq_t</a> *&#160;</td>
          <td class="paramname"><em>nodebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return received scan points even if it's not complete scan</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodebuffer</td><td>Buffer provided by the caller application to store the scan data</td></tr>
    <tr><td class="paramname">count</td><td>Once the interface returns, this parameter will store the actual received data count.</td></tr>
  </table>
  </dd>
</dl>
<p>The interface will return SL_RESULT_OPERATION_TIMEOUT to indicate that not even a single node can be retrieved since last call. <br  />
 </p>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#aa86ca45fbf3bf4748e84febdd3f08942">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#a053211140a1ad4387ea3c1fe25d5e558">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="adb5eb71aa411f326980f3f9d5cb5fc56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5eb71aa411f326980f3f9d5cb5fc56">&#9670;&nbsp;</a></span>grabScanDataHq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::grabScanDataHq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__lidar__response__measurement__node__hq__t.html">sl_lidar_response_measurement_node_hq_t</a> *&#160;</td>
          <td class="paramname"><em>nodebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait and grab a complete 0-360 degree scan data previously received. The grabbed scan data returned by this interface always has the following charactistics:</p>
<p>1) The first node of the grabbed data array (nodebuffer[0]) must be the first sample of a scan, i.e. the start_bit == 1 2) All data nodes are belong to exactly ONE complete 360-degrees's scan 3) Note, the angle data in one scan may not be ascending. You can use API ascendScanData to reorder the nodebuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodebuffer</td><td>Buffer provided by the caller application to store the scan data</td></tr>
    <tr><td class="paramname">count</td><td>The caller must initialize this parameter to set the max data count of the provided buffer (in unit of rplidar_response_measurement_node_t). Once the interface returns, this parameter will store the actual received data count.</td></tr>
    <tr><td class="paramname">timeout</td><td>Max duration allowed to wait for a complete scan data, nothing will be stored to the nodebuffer if a complete 360-degrees' scan data cannot to be ready timely.</td></tr>
  </table>
  </dd>
</dl>
<p>The interface will return SL_RESULT_OPERATION_TIMEOUT to indicate that no complete 360-degrees' scan can be retrieved withing the given timeout duration.</p>
<p>\The caller application can set the timeout value to Zero(0) to make this interface always returns immediately to achieve non-block operation. </p>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#aff7829a9579731777b96174cc21438cb">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#a578ad87045ef6ad2dcbe59effb3a2f67">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="a034fa50c987a807d04fc5f67fbedaa14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034fa50c987a807d04fc5f67fbedaa14">&#9670;&nbsp;</a></span>grabScanDataHqWithTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::grabScanDataHqWithTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsl__lidar__response__measurement__node__hq__t.html">sl_lidar_response_measurement_node_hq_t</a> *&#160;</td>
          <td class="paramname"><em>nodebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u64 &amp;&#160;</td>
          <td class="paramname"><em>timestamp_uS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait and grab a complete 0-360 degree scan data previously received with timestamp support.</p>
<p>The returned timestamp belongs to the first data point of the scan data (begining of the scan). Its value is represented based on the current machine's time domain with the unit of microseconds (uS).</p>
<p>If the currently connected LIDAR supports hardware timestamp mechanism, this timestamp will use the actual data emitted by the LIDAR device and remap it to the current machine's time domain.</p>
<p>For other models that do not support hardware timestamps, this data will be deducted through estimation, and there may be a slight deviation from the actual situation.</p>
<p>The grabbed scan data returned by this interface always has the following charactistics:</p>
<p>1) The first node of the grabbed data array (nodebuffer[0]) must be the first sample of a scan, i.e. the start_bit == 1 2) All data nodes are belong to exactly ONE complete 360-degrees's scan 3) Note, the angle data in one scan may not be ascending. You can use API ascendScanData to reorder the nodebuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodebuffer</td><td>Buffer provided by the caller application to store the scan data</td></tr>
    <tr><td class="paramname">count</td><td>The caller must initialize this parameter to set the max data count of the provided buffer (in unit of rplidar_response_measurement_node_t). Once the interface returns, this parameter will store the actual received data count.</td></tr>
    <tr><td class="paramname">timestamp_uS</td><td>The reference used to store the timestamp value. </td></tr>
    <tr><td class="paramname">timeout</td><td>Max duration allowed to wait for a complete scan data, nothing will be stored to the nodebuffer if a complete 360-degrees' scan data cannot to be ready timely.</td></tr>
  </table>
  </dd>
</dl>
<p>The interface will return SL_RESULT_OPERATION_TIMEOUT to indicate that no complete 360-degrees' scan can be retrieved withing the given timeout duration.</p>
<p>\The caller application can set the timeout value to Zero(0) to make this interface always returns immediately to achieve non-block operation. </p>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#ab932fce9d1997fbf54ba688d0f0bc672">sl::SlamtecLidarDriver</a>.</p>

</div>
</div>
<a id="a3866969a8f20dc4864121dbb3a0e18f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3866969a8f20dc4864121dbb3a0e18f4">&#9670;&nbsp;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sl::ILidarDriver::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the connection is established </p>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#a02f40d78ab5116c7f265303a5eee8706">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#a0b410eaa3ff9805b7e44fe6e7828069b">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="a85da9fd603f808e837f7369450642e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85da9fd603f808e837f7369450642e47">&#9670;&nbsp;</a></span>negotiateSerialBaudRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::negotiateSerialBaudRate </td>
          <td>(</td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>requiredBaudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32 *&#160;</td>
          <td class="paramname"><em>baudRateDetected</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ask the LIDAR to use a new baudrate for serial communication The target LIDAR system must support such feature to work. This function does NOT check whether the target LIDAR works with the requiredBaudRate or not. In order to verifiy the result, use getDeviceInfo or other getXXXX functions instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requiredBaudRate</td><td>The new baudrate required to be used. It MUST matches with the baudrate of the binded channel. </td></tr>
    <tr><td class="paramname">baudRateDetected</td><td>The actual baudrate detected by the LIDAR system </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SL__LidarDriver.html#a388a5b7429d41e8386d7ce5e686ff062">sl::SL_LidarDriver</a>, and <a class="el" href="classsl_1_1SlamtecLidarDriver.html#acada51257ab9d810110637fe2bffd3e7">sl::SlamtecLidarDriver</a>.</p>

</div>
</div>
<a id="adfe7498ef58a56502a09f90db9b2a02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe7498ef58a56502a09f90db9b2a02d">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::reset </td>
          <td>(</td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeoutInMs</em> = <code>DEFAULT_TIMEOUT</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ask the LIDAR core system to reset it self The host system can use the Reset operation to help LIDAR escape the self-protection mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The operation timeout value (in millisecond) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SL__LidarDriver.html#accb2a47f4429525ee00905b2cde1f1a1">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="a13e0904a036153e2074c76e3b884d64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e0904a036153e2074c76e3b884d64a">&#9670;&nbsp;</a></span>setLidarIpConf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::setLidarIpConf </td>
          <td>(</td>
          <td class="paramtype">const sl_lidar_ip_conf_t &amp;&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set LPX and S2E series lidar's static IP address</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>Network parameter that LPX series lidar owned </td></tr>
    <tr><td class="paramname">timeout</td><td>The operation timeout value (in millisecond) for the ethernet udp communication </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#a64870a5a5fcbddde500370ea3fef8874">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#abaa869f8eefd05b405e47a31114fbbae">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="a0a99f3cecc26fe23b52f59954c9646fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a99f3cecc26fe23b52f59954c9646fb">&#9670;&nbsp;</a></span>setMotorSpeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::setMotorSpeed </td>
          <td>(</td>
          <td class="paramtype">sl_u16&#160;</td>
          <td class="paramname"><em>speed</em> = <code>DEFAULT_MOTOR_SPEED</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set lidar motor speed The host system can use this operation to set lidar motor speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>The speed value set to lidar</td></tr>
  </table>
  </dd>
</dl>
<p>Note: The function will stop scan if speed is DEFAULT_MOTOR_SPEED. </p>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#a1e266e4886b5b6c76ee3c09f4e6e18f2">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#a9d03866a8789edbbf6fe9a9ecb244d96">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="acaa311abe3245c1c8fc020acd73bb015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa311abe3245c1c8fc020acd73bb015">&#9670;&nbsp;</a></span>startScan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::startScan </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useTypicalScan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsl_1_1LidarScanMode.html">LidarScanMode</a> *&#160;</td>
          <td class="paramname"><em>outUsedScanMode</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start scan</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>Force the core system to output scan data regardless whether the scanning motor is rotating or not. </td></tr>
    <tr><td class="paramname">useTypicalScan</td><td>Use lidar's typical scan mode or use the compatibility mode (2k sps) </td></tr>
    <tr><td class="paramname">options</td><td>Scan options (please use 0) </td></tr>
    <tr><td class="paramname">outUsedScanMode</td><td>The scan mode selected by lidar </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SL__LidarDriver.html#a183a8eaab9cabc75f792dbf2d76e8e83">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="a1bad2a2ca8b338cebf3021acdd9bc77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bad2a2ca8b338cebf3021acdd9bc77e">&#9670;&nbsp;</a></span>startScanExpress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::startScanExpress </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u16&#160;</td>
          <td class="paramname"><em>scanMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsl_1_1LidarScanMode.html">LidarScanMode</a> *&#160;</td>
          <td class="paramname"><em>outUsedScanMode</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_TIMEOUT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start scan in specific mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>Force the core system to output scan data regardless whether the scanning motor is rotating or not. </td></tr>
    <tr><td class="paramname">scanMode</td><td>The scan mode id (use getAllSupportedScanModes to get supported modes) </td></tr>
    <tr><td class="paramname">options</td><td>Scan options (please use 0) </td></tr>
    <tr><td class="paramname">outUsedScanMode</td><td>The scan mode selected by lidar </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SlamtecLidarDriver.html#a2d2cb67d2d281eb0779c8decb75f4023">sl::SlamtecLidarDriver</a>, and <a class="el" href="classsl_1_1SL__LidarDriver.html#ab95e07fedf8dd531e34f94ddc0a25446">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<a id="ad5b330a3fa5b5c6a40aaeb04cda53078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b330a3fa5b5c6a40aaeb04cda53078">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sl_result sl::ILidarDriver::stop </td>
          <td>(</td>
          <td class="paramtype">sl_u32&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>DEFAULT_TIMEOUT</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ask the LIDAR core system to stop the current scan operation and enter idle state. The background thread will be terminated</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The operation timeout value (in millisecond) for the serial port communication <br  />
 </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classsl_1_1SL__LidarDriver.html#adb9bc0afd0141dea32eac1d38bd1b58f">sl::SL_LidarDriver</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/jkan67/b.ob/src/bob_lidar/sdk/include/<a class="el" href="sl__lidar__driver_8h_source.html">sl_lidar_driver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
